#!/bin/bash

##  Copyright (C) 2021..2023  Robin ALEXANDER
##
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <https://www.gnu.org/licenses/>.

DisplayUsage() {

	cat <<- EOF

	${COMMAND} flashes a raspberrypi disk image to a GPT-partitioned device
	and performs a few adjustments to allow the raspberry-pi to boot directly
	from the device.

	Usage:
	${COMMAND} --device|-d device_name --image|-i disk_image

	EOF

	exit 0
}

GetArguments() {
	while [ "$#" -gt 0 ] ; do
		case "${1}" in
			-h|--help) DisplayUsage; exit 0 ;;
			-d|--device) DEVICE_NAME="${2}" ; shift ;;
			-i|--image) DISK_IMAGE="${2}" ; shift ;;
			*) DisplayUsage; exit 1 ;;
		esac
		shift
	done
}

CheckConditions() {

	# Check that the program is run by root
	if [ $(id -u) -ne 0 ]; then
		echo "${COMMAND} must be run as root" >&2
		exit 1
	fi

	# Check that the device exists
	if [ -z ${DEVICE_NAME} ]; then
		echo "Device name not specified" >&2
		exit 2
	fi

	mountpoints=$(lsblk \
		--noheadings --list -o MOUNTPOINT ${DEVICE_NAME} 2>/dev/null \
	)
	if [ ${?} -ne 0 ]; then
		echo "Device ${DEVICE_NAME} not found" >&2
		exit 3
	fi

	# Check that the disk image exists
	if [ -z ${DISK_IMAGE} ]; then
		echo "Disk image not specified" >&2
		exit 4
	fi

	if [ ! -f ${DISK_IMAGE} ]; then
		echo "Disk image ${DISK_IMAGE} not found" >&2
		exit 5
	fi
}

CheckDependencies() {

	while [ "$#" -gt 0 ] ; do
		if [ ! $(which "${1}") ]; then
			echo "Command ${1} not found" >&2
			exit 6
		fi
		shift
	done
}

Cleanup() {

	echo " > Cleaning up..."

	# Unmount partitions and delete the temporary directory
	if [ -d ${TEMP_DIR} ]; then
		if (mount | grep --silent ${TEMP_DIR}); then
			umount ${TEMP_DIR}/*
		fi
		rm -rf ${TEMP_DIR}
	fi

	# Unmap disk image
	if [ ! -z ${LOOP_DEVICE} ]; then
		losetup --detach ${LOOP_DEVICE}
	fi
}

# Initialize the program

## Set constants
readonly COMMAND=$(basename ${0})

## Get arguments
GetArguments $@

## Check conditions
CheckConditions

## Check dependencies
CheckDependencies sgdisk mkfs.fat mkfs.ext4 losetup

## Set program execution flags
set -euo pipefail

## Intercept interruptions
trap Cleanup SIGHUP SIGINT SIGQUIT SIGABRT SIGTERM

# STEP-1: Prepare the GPT device
## unmount the partitions of the specified device, if any
for mp in ${mountpoints}; do
	umount ${mp}
done

## Remove previous content
echo " > Erasing device ${DEVICE_NAME}..."
sgdisk --zap-all ${DEVICE_NAME} 1>/dev/null

## Create the partitions
echo " > Creating partitions on ${DEVICE_NAME}..."
sgdisk \
	--new=0:0:+64M \
	--typecode=0:0700 \
	--change-name=0:boot \
	${DEVICE_NAME} 1>/dev/null 2>&1
sgdisk \
	--new=0:0:0 \
	--typecode=0:8300 \
	--change-name=0:root \
	${DEVICE_NAME} 1>/dev/null 2>&1

## Create an hybrid MBR with partition type "0c" so that bootloader finds it
echo " > Adding hybrid MBR table..."
cat << EOF | gdisk ${DEVICE_NAME} 1>/dev/null
r
h
1
N
0c
N
Y
EE
w
Y
EOF

## Format the partitions
echo " > Creating the file systems..."
mkfs.fat -F 32 -n BOOT ${DEVICE_NAME}1 1>/dev/null 2>&1
mkfs.ext4 -F -L root ${DEVICE_NAME}2 1>/dev/null 2>&1

# STEP-2: Copy the content of the disk image to the GPT device

## Map the disk image to a loop device
LOOP_DEVICE=$(losetup --find --partscan --show ${DISK_IMAGE})

## Create a temporary directory structure
TEMP_DIR=$(mktemp --directory)
mkdir ${TEMP_DIR}/from
mkdir ${TEMP_DIR}/to

## Copy boot partition
mount --read-only ${LOOP_DEVICE}p1 ${TEMP_DIR}/from
mount ${DEVICE_NAME}1 ${TEMP_DIR}/to

echo " > Copying boot-partition files..."
cp --archive ${TEMP_DIR}/from/* ${TEMP_DIR}/to
echo " > Adjusting file /boot/cmdline.txt..."
sed \
	-e 's: init=[[:graph:]]*::' \
	-e 's: fsck.repair=yes::' \
	-e 's: quiet::' \
	-e 's:root=PARTUUID=[0-9,a-f,\-]*:root=PARTLABEL=root:' \
	-i ${TEMP_DIR}/to/cmdline.txt

umount ${LOOP_DEVICE}p1
umount ${DEVICE_NAME}1

## Copy root partition
mount --read-only ${LOOP_DEVICE}p2 ${TEMP_DIR}/from
mount ${DEVICE_NAME}2 ${TEMP_DIR}/to

echo " > Copying root-partition files..."
cp --archive ${TEMP_DIR}/from/* ${TEMP_DIR}/to
echo " > Adjusting file /etc/fstab..."
sed \
	-e 's:^PARTUUID=.*/boot:PARTLABEL=boot \t/boot:' \
	-e 's:^PARTUUID=.*/[[:blank:]]:PARTLABEL=root \t/:' \
	-i ${TEMP_DIR}/to/etc/fstab

umount ${LOOP_DEVICE}p2
umount ${DEVICE_NAME}2

# Clean up and exit
Cleanup
echo "Operation completed"
exit 0
